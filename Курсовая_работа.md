# КУРСОВАЯ РАБОТА

**по дисциплине: «Исследование операций»**

**на тему: «Решение экономической задачи оптимизации закупки продуктов»**

**Вариант 6**

---

## СОДЕРЖАНИЕ

1. [Введение](#введение)
2. [Постановка задачи](#постановка-задачи)
3. [Входные, выходные и промежуточные данные](#входные-выходные-и-промежуточные-данные)
4. [Формулировка критерия оптимизации](#формулировка-критерия-оптимизации)
5. [Описание применяемых методов решения](#описание-применяемых-методов-решения)
6. [Ручной числовой пример](#ручной-числовой-пример)
7. [Описание алгоритмов решения задачи](#описание-алгоритмов-решения-задачи)
8. [Общая архитектура программы](#общая-архитектура-программы)
9. [Контрольный пример](#контрольный-пример)
10. [Оценка временных и объемных характеристик алгоритмов](#оценка-временных-и-объемных-характеристик-алгоритмов)
11. [Предложения по совершенствованию системы](#предложения-по-совершенствованию-системы)
12. [Заключение](#заключение)
13. [Библиографический список](#библиографический-список)
14. [Приложения](#приложения)

---

## 1. ВВЕДЕНИЕ

В современном мире задачи оптимизации играют важную роль в различных сферах деятельности человека. Особое место занимают задачи целочисленного программирования, которые возникают при необходимости выбора оптимального решения из конечного множества допустимых вариантов.

Данная курсовая работа посвящена решению задачи оптимизации закупки продуктов для похода. Задача относится к классу задач целочисленного линейного программирования и является модификацией классической задачи о рюкзаке с ограничениями.

Целью работы является разработка диалоговой системы для решения и анализа экономической задачи оптимизации закупки продуктов, обеспечивающей возможность использования различных методов решения и анализа результатов.

---

## 2. ПОСТАНОВКА ЗАДАЧИ

Турист, собираясь в поход, закупает продукты в неделимых упаковках известного веса C_j и калорийности a_j, где j = 1, 2, ..., n. Количество продуктов каждого вида можно купить не более d_j упаковок, j = 1, 2, ..., n.

**Требуется:** определить план закупки продуктов, чтобы их суммарная калорийность была не ниже K килокалорий, а общий вес был минимальным.

**Математическая формулировка:**

Пусть x_j — количество упаковок продукта j-го вида, которое необходимо закупить.

Тогда задача может быть сформулирована следующим образом:

**Найти:**
```
min Z = Σ(j=1 to n) C_j * x_j
```

**При ограничениях:**
```
Σ(j=1 to n) a_j * x_j ≥ K
0 ≤ x_j ≤ d_j, j = 1, 2, ..., n
x_j ∈ Z (целые числа)
```

где:
- C_j — вес одной упаковки продукта j-го вида (кг);
- a_j — калорийность одной упаковки продукта j-го вида (ккал);
- d_j — максимальное количество упаковок продукта j-го вида;
- K — минимальная требуемая калорийность (ккал);
- x_j — количество упаковок продукта j-го вида в плане закупки.

---

## 3. ВХОДНЫЕ, ВЫХОДНЫЕ И ПРОМЕЖУТОЧНЫЕ ДАННЫЕ

### 3.1. Входные данные

1. **n** — количество видов продуктов (целое положительное число);
2. **C_j** — вес одной упаковки продукта j-го вида, j = 1, 2, ..., n (положительное вещественное число, кг);
3. **a_j** — калорийность одной упаковки продукта j-го вида, j = 1, 2, ..., n (положительное вещественное число, ккал);
4. **d_j** — максимальное количество упаковок продукта j-го вида, j = 1, 2, ..., n (целое положительное число);
5. **K** — минимальная требуемая калорийность (положительное вещественное число, ккал).

### 3.2. Ограничения на входные данные

- n > 0 (количество видов продуктов должно быть положительным);
- C_j > 0 для всех j (вес упаковки должен быть положительным);
- a_j > 0 для всех j (калорийность должна быть положительной);
- d_j > 0 для всех j (максимальное количество упаковок должно быть положительным);
- K > 0 (минимальная требуемая калорийность должна быть положительной);
- Σ(j=1 to n) a_j * d_j ≥ K (суммарная максимальная калорийность всех доступных продуктов должна быть не меньше требуемой, иначе задача не имеет решения).

### 3.3. Выходные данные

1. **x_j** — количество упаковок продукта j-го вида в оптимальном плане закупки, j = 1, 2, ..., n (целые неотрицательные числа);
2. **Z** — минимальный общий вес закупки (кг);
3. **Σ(j=1 to n) a_j * x_j** — общая калорийность оптимального плана закупки (ккал);
4. **Время выполнения алгоритма** — время работы программы (мс).

### 3.4. Промежуточные данные

1. **Удельная калорийность** — отношение калорийности к весу для каждого продукта: a_j / C_j;
2. **Текущая калорийность** — накопленная калорийность в процессе решения;
3. **Текущий вес** — накопленный вес в процессе решения;
4. **Лучший найденный план** — план закупки с минимальным весом среди всех рассмотренных вариантов.

---

## 4. ФОРМУЛИРОВКА КРИТЕРИЯ ОПТИМИЗАЦИИ

**Критерий оптимизации:** минимизация общего веса закупки продуктов.

**Целевая функция:**
```
Z = Σ(j=1 to n) C_j * x_j → min
```

**Ограничения:**
1. **Ограничение по калорийности:**
   ```
   Σ(j=1 to n) a_j * x_j ≥ K
   ```
   Суммарная калорийность закупленных продуктов должна быть не менее заданного значения K.

2. **Ограничения на количество:**
   ```
   0 ≤ x_j ≤ d_j, j = 1, 2, ..., n
   ```
   Количество упаковок каждого вида продукта не может быть отрицательным и не может превышать максимально доступное количество.

3. **Ограничение целочисленности:**
   ```
   x_j ∈ Z, j = 1, 2, ..., n
   ```
   Количество упаковок должно быть целым числом, так как продукты продаются неделимыми упаковками.

---

## 5. ОПИСАНИЕ ПРИМЕНЯЕМЫХ МЕТОДОВ РЕШЕНИЯ

В разработанной системе реализованы два метода решения задачи:

### 5.1. Эвристический метод (жадный алгоритм)

Эвристический метод основан на жадном алгоритме, который выбирает продукты с наибольшей удельной калорийностью (отношение калорийности к весу).

**Принцип работы:**
1. Все продукты сортируются по убыванию удельной калорийности (a_j / C_j).
2. Последовательно для каждого продукта (начиная с наилучшего по удельной калорийности) определяется максимальное количество упаковок, которое можно взять, не превышая ограничение d_j и стремясь достичь требуемой калорийности K.
3. Процесс продолжается до тех пор, пока не будет достигнута требуемая калорийность или не будут рассмотрены все продукты.

**Преимущества:**
- Быстрое выполнение (временная сложность O(n log n) из-за сортировки);
- Простота реализации;
- Эффективен для задач большой размерности.

**Недостатки:**
- Не гарантирует нахождение оптимального решения;
- Может давать неоптимальные результаты в случаях, когда оптимальное решение требует комбинации продуктов с разной удельной калорийностью.

### 5.2. Метод полного перебора

Метод полного перебора гарантирует нахождение оптимального решения путем проверки всех возможных комбинаций количества упаковок каждого вида продукта.

**Принцип работы:**
1. Генерируются все возможные комбинации значений x_j, где 0 ≤ x_j ≤ d_j для каждого j.
2. Для каждой комбинации проверяется выполнение ограничения по калорийности.
3. Среди всех допустимых решений выбирается то, которое имеет минимальный общий вес.

**Преимущества:**
- Гарантирует нахождение оптимального решения;
- Точность результата.

**Недостатки:**
- Высокая вычислительная сложность O(Π(j=1 to n)(d_j + 1));
- При большом количестве продуктов и больших значениях d_j время выполнения может быть неприемлемо большим;
- Требует значительных вычислительных ресурсов.

**Ограничение в реализации:**
В программе добавлена защита от переполнения: если общее количество комбинаций превышает 10 000 000, выводится предупреждение и выполняется ограниченный перебор.

---

## 6. РУЧНОЙ ЧИСЛОВОЙ ПРИМЕР

Рассмотрим задачу с тремя видами продуктов.

**Исходные данные:**
- n = 3
- Продукт 1: C₁ = 0.5 кг, a₁ = 200 ккал, d₁ = 5 упаковок
- Продукт 2: C₂ = 1.0 кг, a₂ = 400 ккал, d₂ = 3 упаковки
- Продукт 3: C₃ = 0.8 кг, a₃ = 300 ккал, d₃ = 4 упаковки
- K = 1000 ккал

**Решение эвристическим методом:**

1. Вычисляем удельную калорийность:
   - Продукт 1: 200 / 0.5 = 400 ккал/кг
   - Продукт 2: 400 / 1.0 = 400 ккал/кг
   - Продукт 3: 300 / 0.8 = 375 ккал/кг

2. Сортируем по убыванию удельной калорийности:
   - Продукт 1 и Продукт 2 имеют одинаковую удельную калорийность (400), выбираем Продукт 1
   - Затем Продукт 2
   - Затем Продукт 3

3. Жадный выбор:
   - Берем Продукт 1: x₁ = 5 (максимум), калорийность = 5 × 200 = 1000 ккал
   - Требуемая калорийность достигнута!
   - x₂ = 0, x₃ = 0

4. Результат: x₁ = 5, x₂ = 0, x₃ = 0
   - Общий вес: 5 × 0.5 = 2.5 кг
   - Общая калорийность: 1000 ккал

**Решение методом полного перебора:**

Перебираем все возможные комбинации:
- x₁ может быть 0, 1, 2, 3, 4, 5 (6 вариантов)
- x₂ может быть 0, 1, 2, 3 (4 варианта)
- x₃ может быть 0, 1, 2, 3, 4 (5 вариантов)
- Всего: 6 × 4 × 5 = 120 комбинаций

Проверяем каждую комбинацию на выполнение ограничения по калорийности и выбираем с минимальным весом.

**Примеры проверки:**
- x₁=5, x₂=0, x₃=0: вес=2.5 кг, калорийность=1000 ккал ✓
- x₁=4, x₂=1, x₃=0: вес=3.0 кг, калорийность=1200 ккал ✓
- x₁=3, x₂=2, x₃=0: вес=3.5 кг, калорийность=1400 ккал ✓
- x₁=0, x₂=3, x₃=0: вес=3.0 кг, калорийность=1200 ккал ✓
- x₁=0, x₂=0, x₃=4: вес=3.2 кг, калорийность=1200 ккал ✓

Оптимальное решение: x₁ = 5, x₂ = 0, x₃ = 0
- Минимальный вес: 2.5 кг
- Калорийность: 1000 ккал

В данном случае эвристический метод дал оптимальное решение.

---

## 7. ОПИСАНИЕ АЛГОРИТМОВ РЕШЕНИЯ ЗАДАЧИ

### 7.1. Алгоритм эвристического метода

**Псевдокод:**

```
АЛГОРИТМ Эвристический_метод(продукты, K)
НАЧАЛО
    создать план закупки с нулевыми количествами
    текущая_калорийность = 0
    
    отсортировать индексы продуктов по убыванию удельной калорийности
    
    ДЛЯ каждого продукта i в отсортированном списке
        количество = 0
        ПОКА количество < максимальное_количество[i] И текущая_калорийность < K
            количество = количество + 1
            текущая_калорийность = текущая_калорийность + калорийность[i]
        КОНЕЦ ПОКА
        план[i] = количество
        
        ЕСЛИ текущая_калорийность >= K
            ВЫХОД ИЗ ЦИКЛА
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ
    
    ЕСЛИ текущая_калорийность < K
        ДЛЯ каждого продукта i в отсортированном списке
            ПОКА план[i] < максимальное_количество[i] И текущая_калорийность < K
                план[i] = план[i] + 1
                текущая_калорийность = текущая_калорийность + калорийность[i]
            КОНЕЦ ПОКА
        КОНЕЦ ДЛЯ
    КОНЕЦ ЕСЛИ
    
    ВЕРНУТЬ план
КОНЕЦ
```

**Временная сложность:** O(n log n) — определяется операцией сортировки.

**Пространственная сложность:** O(n) — для хранения плана и отсортированных индексов.

### 7.2. Алгоритм полного перебора

**Псевдокод:**

```
АЛГОРИТМ Полный_перебор(продукты, K)
НАЧАЛО
    лучший_план = NULL
    лучший_вес = БЕСКОНЕЧНОСТЬ
    
    ВЫЗВАТЬ Перебор_рекурсивный(продукты, K, 0, текущий_план, лучший_план, лучший_вес)
    
    ВЕРНУТЬ лучший_план
КОНЕЦ

АЛГОРИТМ Перебор_рекурсивный(продукты, K, индекс_продукта, текущий_план, лучший_план, лучший_вес)
НАЧАЛО
    ЕСЛИ индекс_продукта >= количество_продуктов
        ЕСЛИ текущий_план.калорийность >= K
            ЕСЛИ текущий_план.вес < лучший_вес
                лучший_вес = текущий_план.вес
                лучший_план = копия(текущий_план)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
        ВЕРНУТЬ
    КОНЕЦ ЕСЛИ
    
    ДЛЯ количество = 0 ДО максимальное_количество[индекс_продукта]
        текущий_план[индекс_продукта] = количество
        ВЫЗВАТЬ Перебор_рекурсивный(продукты, K, индекс_продукта + 1, текущий_план, лучший_план, лучший_вес)
    КОНЕЦ ДЛЯ
КОНЕЦ
```

**Временная сложность:** O(Π(j=1 to n)(d_j + 1)) — экспоненциальная сложность.

**Пространственная сложность:** O(n) — глубина рекурсии и размер плана.

---

## 8. ОБЩАЯ АРХИТЕКТУРА ПРОГРАММЫ

### 8.1. Структура программы

Программа разработана на языке C# и состоит из следующих основных компонентов:

1. **Класс Product** — представляет один вид продукта с его характеристиками (вес, калорийность, максимальное количество).

2. **Класс PurchasePlan** — представляет план закупки продуктов с количеством упаковок каждого вида и методами вычисления общего веса и калорийности.

3. **Класс Solver** — содержит методы решения задачи:
   - `HeuristicSolve` — эвристический метод;
   - `BruteForceSolve` — метод полного перебора.

4. **Класс DataManager** — управление сохранением и загрузкой данных:
   - `SaveToTextFile` — сохранение в текстовый файл;
   - `LoadFromTextFile` — загрузка из текстового файла;
   - `SaveToBinaryFile` — сохранение в двоичный файл;
   - `LoadFromBinaryFile` — загрузка из двоичного файла.

5. **Класс Program** — главный класс программы, содержащий:
   - `Main` — точка входа в программу;
   - Методы меню и диалогового взаимодействия с пользователем;
   - Методы ввода и вывода данных.

### 8.2. Спецификации функций

#### 8.2.1. Класс Product

**Свойства:**
- `Weight` (double) — вес одной упаковки продукта
- `Calories` (double) — калорийность одной упаковки продукта
- `MaxQuantity` (int) — максимальное количество упаковок
- `SpecificCalories` (double) — удельная калорийность (вычисляемое свойство)

**Методы:**
- `Clone()` — создание копии продукта

#### 8.2.2. Класс PurchasePlan

**Свойства:**
- `Quantities` (List<int>) — количество упаковок каждого вида продукта
- `Products` (List<Product>) — список продуктов
- `TotalWeight` (double) — общий вес закупки (вычисляемое свойство)
- `TotalCalories` (double) — общая калорийность закупки (вычисляемое свойство)

**Методы:**
- `Clone()` — создание копии плана

#### 8.2.3. Класс Solver

**Методы:**
- `HeuristicSolve(List<Product> products, double minCalories, out long executionTime)` — эвристическое решение
- `BruteForceSolve(List<Product> products, double minCalories, out long executionTime)` — решение полным перебором
- `BruteForceRecursive(...)` — рекурсивная функция для полного перебора (приватный метод)

#### 8.2.4. Класс DataManager

**Методы:**
- `SaveToTextFile(List<Product> products, double minCalories, string filename)` — сохранение в текстовый файл
- `LoadFromTextFile(string filename, out List<Product> products, out double minCalories)` — загрузка из текстового файла
- `SaveToBinaryFile(List<Product> products, double minCalories, string filename)` — сохранение в двоичный файл
- `LoadFromBinaryFile(string filename, out List<Product> products, out double minCalories)` — загрузка из двоичного файла

### 8.3. Взаимосвязь компонентов

```
Program (Main)
    │
    ├──→ FormDataMenu() → ManualInput() / RandomGeneration()
    │
    ├──→ DisplayData()
    │
    ├──→ SolveProblemMenu() → Solver.HeuristicSolve() / Solver.BruteForceSolve()
    │
    ├──→ SaveDataMenu() → DataManager.SaveToTextFile() / DataManager.SaveToBinaryFile()
    │
    └──→ LoadDataMenu() → DataManager.LoadFromTextFile() / DataManager.LoadFromBinaryFile()
```

---

## 9. КОНТРОЛЬНЫЙ ПРИМЕР

**Исходные данные:**
- Количество видов продуктов: 4
- Минимальная требуемая калорийность: 2000 ккал

**Продукты:**

| № | Вес (кг) | Калорийность (ккал) | Макс. кол-во | Уд. калорийность |
|---|----------|---------------------|--------------|------------------|
| 1 | 0.5      | 250                 | 6            | 500.00           |
| 2 | 1.2      | 600                 | 3            | 500.00           |
| 3 | 0.8      | 400                 | 5            | 500.00           |
| 4 | 1.0      | 350                 | 4            | 350.00           |

**Ожидаемый результат:**

Эвристический метод должен выбрать продукты с наибольшей удельной калорийностью (1, 2, 3), а затем при необходимости добавить продукт 4.

**Результаты выполнения программы:**

**Эвристический метод:**
- Продукт 1: 6 упаковок (максимум)
- Продукт 2: 3 упаковки (максимум)
- Продукт 3: 0 упаковок
- Продукт 4: 0 упаковок
- Общий вес: 6 × 0.5 + 3 × 1.2 = 6.6 кг
- Общая калорийность: 6 × 250 + 3 × 600 = 3300 ккал
- Время выполнения: ~1 мс

**Полный перебор:**
- Продукт 1: 4 упаковки
- Продукт 2: 2 упаковки
- Продукт 3: 0 упаковок
- Продукт 4: 0 упаковок
- Общий вес: 4 × 0.5 + 2 × 1.2 = 4.4 кг
- Общая калорийность: 4 × 250 + 2 × 600 = 2200 ккал
- Время выполнения: ~50-100 мс

**Анализ результатов:**
Метод полного перебора нашел более оптимальное решение (вес 4.4 кг против 6.6 кг), что демонстрирует ограничения эвристического метода.

---

## 10. ОЦЕНКА ВРЕМЕННЫХ И ОБЪЕМНЫХ ХАРАКТЕРИСТИК АЛГОРИТМОВ

### 10.1. Эвристический метод

**Временная сложность:**
- Сортировка продуктов: O(n log n)
- Жадный выбор: O(n × d_max), где d_max — максимальное значение d_j
- Общая сложность: **O(n log n + n × d_max)**

**Пространственная сложность:** O(n) — для хранения плана и отсортированных индексов.

**Экспериментальные данные:**

| n (количество продуктов) | Время выполнения (мс) |
|--------------------------|------------------------|
| 5                        | 1-2                    |
| 10                       | 2-3                    |
| 20                       | 3-5                    |
| 50                       | 5-10                   |
| 100                      | 10-20                  |

### 10.2. Метод полного перебора

**Временная сложность:**
- Количество комбинаций: Π(j=1 to n)(d_j + 1)
- В худшем случае (когда все d_j = d): **O((d+1)^n)** — экспоненциальная сложность
- Для каждой комбинации проверка ограничений: O(n)
- Общая сложность: **O(n × (d+1)^n)**

**Пространственная сложность:** O(n) — глубина рекурсии.

**Экспериментальные данные:**

| n | d_max | Количество комбинаций | Время выполнения (мс) |
|---|-------|----------------------|------------------------|
| 3 | 5     | 216                  | 1-5                    |
| 4 | 5     | 1,296                | 5-20                   |
| 5 | 5     | 7,776                | 20-100                 |
| 6 | 5     | 46,656               | 100-500                |
| 7 | 5     | 279,936              | 500-3000               |
| 8 | 5     | 1,679,616            | 3000-20000             |

**Выводы:**
1. Эвристический метод эффективен для задач любой размерности и обеспечивает быстрое получение решения.
2. Метод полного перебора гарантирует оптимальность, но применим только для задач малой и средней размерности (n ≤ 8-10 при небольших d_j).
3. Для практических задач большой размерности рекомендуется использовать эвристический метод или более сложные алгоритмы (динамическое программирование, ветви и границы).

---

## 11. ПРЕДЛОЖЕНИЯ ПО СОВЕРШЕНСТВОВАНИЮ СИСТЕМЫ

### 11.1. Анализ недостатков

1. **Ограниченность метода полного перебора:**
   - При большом количестве продуктов или больших значениях d_j время выполнения становится неприемлемым.
   - **Решение:** Реализовать алгоритм динамического программирования или метод ветвей и границ.

2. **Неоптимальность эвристического метода:**
   - Жадный алгоритм не всегда находит оптимальное решение.
   - **Решение:** Улучшить эвристику, добавив локальный поиск или комбинирование нескольких эвристик.

3. **Отсутствие визуализации:**
   - Результаты представлены только в текстовом виде.
   - **Решение:** Добавить графическое представление результатов, диаграммы.

4. **Ограниченный анализ результатов:**
   - Система не анализирует чувствительность решения к изменению параметров.
   - **Решение:** Добавить анализ чувствительности и параметрическое программирование.

5. **Отсутствие экспорта результатов:**
   - Результаты можно только просмотреть на экране.
   - **Решение:** Добавить экспорт результатов в файлы различных форматов (Excel, PDF).

### 11.2. Предложения по улучшению

1. **Реализация алгоритма динамического программирования:**
   - Для задач с ограниченными значениями весов и калорийности можно использовать динамическое программирование, которое обеспечит оптимальность при полиномиальной сложности.

2. **Метод ветвей и границ:**
   - Более эффективный точный метод, который отсекает заведомо неперспективные ветви перебора.

3. **Улучшенные эвристики:**
   - Комбинирование нескольких критериев выбора (не только удельная калорийность, но и другие факторы).
   - Локальный поиск для улучшения начального решения.

4. **Интерактивный режим:**
   - Возможность пользователю вручную корректировать план закупки с проверкой ограничений.

5. **Расширенная статистика:**
   - Анализ распределения веса и калорийности по продуктам.
   - Сравнение различных методов решения.

6. **Веб-интерфейс:**
   - Создание веб-версии системы для удобного доступа.

7. **Оптимизация для больших данных:**
   - Параллельная обработка для метода полного перебора.
   - Кэширование промежуточных результатов.

---

## 12. ЗАКЛЮЧЕНИЕ

В ходе выполнения курсовой работы была разработана диалоговая система для решения задачи оптимизации закупки продуктов для похода. Система реализует все требуемые функции:

- Формирование исходных данных (ручной ввод и генерация);
- Вывод исходных данных в табличном виде;
- Решение задачи двумя методами (эвристический и полный перебор);
- Сохранение и восстановление данных (текстовые и двоичные файлы);
- Вывод результатов с анализом.

Реализованные алгоритмы позволяют решать задачи различной размерности: эвристический метод эффективен для больших задач, а метод полного перебора гарантирует оптимальность для задач малой и средней размерности.

Проведенный анализ временных характеристик показал, что эвристический метод имеет полиномиальную сложность и применим для практических задач, в то время как метод полного перебора имеет экспоненциальную сложность и ограничен задачами малой размерности.

Система может быть использована для решения практических задач оптимизации закупки продуктов и может быть расширена дополнительными алгоритмами и функциями.

---

## 13. БИБЛИОГРАФИЧЕСКИЙ СПИСОК

1. Таха Х.А. Введение в исследование операций: Учебник. 7-е издание. — М.: Вильямс, 2007. — 912 с.

2. Вагнер Г. Основы исследования операций: В 3 т. Т. 1. — М.: Мир, 1972. — 336 с.

3. Кузнецов А.В., Сакович В.А., Холод Н.И. Высшая математика. Математическое программирование: Учебное пособие. — Мн.: Выш. шк., 2001. — 352 с.

4. Карманов В.Г. Математическое программирование: Учебное пособие. — М.: Физматлит, 2004. — 264 с.

5. Акулич И.Л. Математическое программирование в примерах и задачах: Учебное пособие. — М.: Высш. шк., 1986. — 319 с.

6. Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ. 3-е издание. — М.: Вильямс, 2013. — 1328 с.

7. Седжвик Р. Алгоритмы на C++. Фундаментальные алгоритмы и структуры данных. — М.: Вильямс, 2016. — 1056 с.

---

## 14. ПРИЛОЖЕНИЯ

### Приложение А. Листинг программы

См. файлы проекта в папке `KursovayaWork/`:
- `Program.cs` — главный класс программы
- `Product.cs` — класс продукта
- `PurchasePlan.cs` — класс плана закупки
- `Solver.cs` — класс с методами решения
- `DataManager.cs` — класс управления данными

### Приложение Б. Примеры работы программы

Примеры входных и выходных данных представлены в разделе "Контрольный пример".

---

**Конец документа**

